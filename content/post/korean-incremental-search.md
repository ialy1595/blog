---
title: "한글의 incremental search UX 와 인코딩"
date: 2019-02-27T21:59:53+09:00
categories: ["code"]
subcategories: ["etc"]
tags: []
draft: true
nextp: ""
prevp: ""
---

# 한글 검색의 문제점

우리는 수많은 데이터 속에서 살아간다. 이렇게 많은 데이터 속에서 내가 원하는 정보를 얻기 위해 검색이라는 기능은 필수적이다. 세계적으로 보면 구글, 한국에서 보면 네이버 처럼 검색 엔진을 기반으로 둔 기업이 크게 성장한 것만 봐도 검색이라는 기능이 얼마나 중요한지 알 수 있다.

예전의 검색 시스템은 검색어를 전부 치고난 후 엔터를 눌러야 결과가 나왔었다. 그러나 요즘은 엔터를 누르지 않아도 검색창에 한글자 한글자 칠 때마다 바로바로 결과가 갱신되서 나오는 검색을 지원하는 곳이 많다. 이러한 검색 시스템을 incremental search(증분검색), 다른 말로는 find as you type(FAYT)라고 한다. Incremental search는 크게 두 가지 장점이 있다.

 - **글자를 필요한 만큼만 칠 수 있다.** 글자를 다 친 다음에 엔터를 쳐야하는 경우 얼마나 많은 글자를 넣어야 내가 원하는 결과가 추출될지 알 수 없기 때문에 필요 이상으로 글자를 치게 되거나 필요한 양 보다 부족하게 쳐서 여러번 검색하게 된다. 그러나 결과가 바로바로 갱신되는 경우 점점 좁혀지는 과정을 보면서 내게 딱 필요한 수준에서 멈출 수 있다.
 - **오타를 바로 감지할 수 있다.** 오타라는 것은 내가 치는 과정에서 감지하지 못하기에 오타이다. 그렇기 때문에 예전 검색 시스템이라면 타자를 다 치고 엔터를 누르고 나서야 결과가 이상하다는 것을 보고 오타가 있었다는 것을 알아챌 수 있었다. 그러나 바로바로 결과가 갱신되는 경우 오타가 나는 순간 이상해진 결과를 보고 바로 알아챌 수 있다.

하지만 이것이 과연 한글 사용자에게도 좋은 UX(User eXperience)일까?

한글은 다른 문자들과 달리 초성, 중성, 종성이 모여서 한 글자를 이루는 시스템이다. 물론 이러한 특성 덕분에 다른 글자들에 비해 배우기 쉬우면서도 수많은 음을 표현할 수 있다. 하지만 이 시스템은 검색 UX에서 오히려 단점으로 작용한다.

예를 들어 `army`와 `군대`를 검색하는 경우를 비교해보자. `army`의 경우 사용자는 다음과 같은 경험을 한다.

 1. `a`를 검색했을 때 `army`가 결과 목록에 **<bb>포함된다.</bb>**
 2. `ar`를 검색했을 때 `army`가 결과 목록에 **<bb>포함된다.</bb>**
 3. `arm`를 검색했을 때 `army`가 결과 목록에 **<bb>포함된다.</bb>**
 4. `army`를 검색했을 때 `army`가 결과 목록에 **<bb>포함된다.</bb>**

영어로 검색하는 경우 위와 같이 자연스럽고 연속적인 경험을 할 수 있다. 그러나 한글은 이와 같은 경험을 제공해주지 못한다. `군대`가 검색되는 과정을 살펴보자.

 1. `ㄱ`을 검색했을 떼 `군대`가 결과 목록에 **<rr>포함되지 않는다.</rr>**
 2. `구`을 검색했을 떼 `군대`가 결과 목록에 **<rr>포함되지 않는다.</rr>**
 3. `군`을 검색했을 떼 `군대`가 결과 목록에 **<bb>포함된다.</bb>**
 4. `군ㄷ`을 검색했을 떼 `군대`가 결과 목록에 **<rr>포함되지 않는다.</rr>**
 5. `군대`을 검색했을 떼 `군대`가 결과 목록에 **<bb>포함되지 않는다.</bb>**

이렇게 글자를 완성해 나가는 과정에서 나와야 하는 결과가 포함되었다 안 되었다를 반복하게 된다. 왜냐하면 영어의 경우 자연스럽게 한글자 한글자 칠 때마다 생성되는 문자열이 내가 치고자 하는 문자열의 [부분문자열](부분문자열 링크)이 되지만, 한글은 초성 중성 종성 시스템 때문에 두세번을 쳐야 한 글자가 완성되고, 이 과정에서 `구`와 `군`이 다른 글자인것 처럼 원래 치고자 하는 문자열에 없는 문자가 들어가게 되기 때문에 위와 같은 불연속적인 UX가 나오게 되는 것이다. 이제 이 문제를 해결해서 부드러운 한글 검색을 구현해보자. 

# 부드러운 한글 검색 구현

## 구현 개요

문제를 해결하기 위해서는 구체적인 원인 분석이 필요하다. 위와 같은 문제가 생기는 이유는 `군`을 검색하는 과정에서 `ㄱ != 군`, `구 != 군`이기 때문에 `군`이 들어간 결과가 나오지 않게 되는 것이다. 이를 해결하려면 어떻게 해야할까? 간단히 말하면 `ㄱ == 군`, `구 == 군`이 되도록 하면 된다. 더 자세히 말하자면 `군`이 완성되가는 과정인 `ㄱ`,  `구`,  `군`이 모두 `군`과 같다는 결과가 나오는 비교함수를 만들면 된다. 이 함수는 다음과 같이 만들 수 있다.

 1. 이 비교함수는 다른 비교함수와 달리 교환법칙이 성립이 안된다. 왜냐하면 `구`는 `군`을 만드는 과정에 있지만, `군`은 `구`를 만드는 과정에 없기 때문이다. 따라서 이 둘을 분리하기 위해 우리가 검색창에 치는 글자를 `s`, 검색되는 대상의 글자를 `d`라고 하자.
 2. `s`와 `d`가 모두 한글인 경우가 아니라면 원래 비교함수처럼  `return (s == d)`를 반환한다.
 3. `d`가 만들어지는 과정을 리스트로 반환하는 함수인 `kr_list()`를 만든다. 예를 들어 `kr_list('군')`은 `['ㄱ', '구', '군']`을 반환하고, `kr_list('대')`은 `['ㄷ', '대']`를 반환한다.
 4. 저 리스트 중에 `s`가 존재할 경우 `True`를 반환한다. 따라서 `return (s in kr_list(d))`를 하면 된다. 

따라서 이를 python으로 구현하면 다음과 같다.

```
def eq_kr(s, d):
    if is_kr(s) and is_kr(d):
        return (s in kr_list(d))
    else:
        return (s == d)
```

이제 한글인지 확인하는 함수인 `is_kr()`과 만들어지는 과정을 반환하는 함수인 `kr_list()` 함수만 구현하면 된다. 이 두 함수를 구현하기 위해서는 한글이 코드상에서는 어떻게 인코딩되고 표현되는지 알아야 한다.

## UTF-8과 Unicode

한글을 인코딩하는 방식 중 가장 많이 쓰이는 것 중 하나는 UTF-8이다. 여기서 UTF는 Universal coded character set + Transformation Format의 약자로, unicode를 변환하는 형식 중 하나라는 뜻이다. 그렇다면 unicode란 무엇일까?

C에서 문자는 character의 약자인 `char`라는 1byte짜리 자료형을 써서 나타낼 수 있다. 이 `char`은 1byte, 즉 8bit이므로 0 ~ 255까지 나타낼 수 있고, 이 256개의 수를 각각 하나씩 문자에 매칭하여 표현한다. 이렇게 매칭한 것을 **ASCII code**라고 한다.

![]()아스키코드 문자표

예전에는 이 ASCII code만 사용해도 큰 문제가 없었다. 그러나 점점 글로벌시대가 되고 한글을 비롯한 수많은 외국어와 다양한 기호들을 표시할 필요가 생기면서, ASCII code를 확장할 필요가 생겼다. 따라서 ASCII code를 확장하여 수많은 기호와 문자들을 포함시킨 것이 Universal code, 즉 **Unicode**다. 

Unicode는 ASCII code를 확장한 것이지만 포함된 문자의 수 외에도 ASCII code와 다른점이 하나 있다. 바로 ASCII code는 매핑임과 동시에 문자를 코드상에 표현하는 인코딩 방식이었다면 **Unicode는 단순히 매핑일 뿐**이라는 것이다. 예를 들어 ASCII code에서 `a`에 해당하는 숫자는 `0x60`이고, 이 때 `0x60`을 문자로 출력하면 `a`가 나온다. 그러나 unicode의 경우 `가`에 해당하는 unicode는 `0xac00`이지만 `0xac00`을 출력한다고 `가`가 나오지 않는다. 즉, Unicode는 실제로 표현하는 인코딩 방식은 따로 존재하고, 이중 하나가 UTF-8이다.

Unicode가 이렇게 매핑과 인코딩을 따로 두는 이유는 **확장성** 때문이다. ASCII code에서 unicode로 확장되면서 많은 문자가 추가되었지만, 아직 그 누구도 세상의 모든 문자를 표현했다고 장담할 수 없고 아직도 계속 추가되는 중이다. 이러한 상황에서 unicode가 매핑과 동시에 한가지 형식으로 인코딩이 고정된다면 그 형식에서 표시할 수 있는 모든 글자의 수를 넘는 경우 또 다시 새로운 시스템을 만들어야만 한다. 따라서 unicode는 매핑에만 중점을 둬서 무한한 추가가 가능하도록 하고, unicode에 포함된 문자가 많아질수록 이를 인코딩하는 형식을 바꿔나가는 형식을 택했다.

Unicode를 인코딩하는 방식 중 한글을 인코딩할 때 많이 쓰이는 UTF-8을 살펴보자. python에서는 `encode()`함수를 통해 문자가 어떻게 인코딩되는지 확인할 수 있다. 예를 들어 입력한 문자가 UTF-8로 어떻게 인코딩 되는지 알고싶다면 다음 코드를 통해 확인할 수 있다.

```
print(input().encode('utf-8'))
```

참고로 `encode()`의 default 값은 UTF-8이기 때문에 괄호 안에 아무것도 안 쓰고 그냥 `encode()`라고 해도 똑같이 동작한다. 하지만 다른 사람이(혹은 미래의 내가) 코드를 봤을 때 알아보기 쉽도록 써주는 것을 추천한다.

먼저 자음에 어떻게 되어있는지 살펴보자. 위의 코드로 `ㄱ`을 뽑아보면 `b\xe3\x84\xb1`이 나온다. 이 글에서는 쉽게 `e3 84 b1`으로 표기하자. 이와 같은 방법으로 `ㄱ`, `ㄴ`, `ㄷ`을 순서대로 뽑아보면

`e3 84 b1`<br/>`e3 84 b4`</br>`e3 84 b7`

이 나온다. 이것만 보면 "아 3씩 차이나서 나오는구나"라고 생각할 수 있다. 그러나 `ㄹ`을 뽑아보면 `e3 84 b9`가 나온다....?! 당황하지 말고 이번엔 역으로 UTF-8 코드를 문자로 출력하는걸 해보자. 이는 `bytearray` 자료형과 `decode()` 함수를 써서 할 수 있다. 예를 들어 `e3 84 b2`를 문자로 출력하는 코드는

```
print(bytearray([0xe3, 0x84, 0xb2]).decode('utf-8'))
```

이 된다. 이 코드를 이용해서 `e3 84 b2`을 뽑아보면 `ㄲ`이 나오고, `e3 84 b3`를 뽑아보면 `ㄳ`이 나온다. 따라서 이 구간에는 쌍자음, 겹자음까지 포함해서 순서대로 저장되어있음을 알 수 있다. `ㄴ` 뒤에는 `ㄵ`과 `ㄶ` 두가지가 있지만 `ㄷ`뒤에는 `ㄸ` 하나밖에 없기 때문에 위와 같이 3차이가 나기도 하고 2차이가 나기도 하는 것이다. 이렇게 순서대로 하나씩 뽑아보면 `ㄿ`까지 `e3 84 bf`로 잘 나온다. 하지만 그 다음 순서인 `ㅀ`을 뽑아보면 `e3 84 c0`이 아니라 `e3 85 80`이 나온다. 이를 통해 우리는 다음과 같은 사실을 유추할 수 있다.

 - `0x80`에서 `0xbf`까지만 사용하고, `0xbf`를 넘어가면 다음 자리로 자리올림된다.

이는 완전체 글자(초성+중성 또는 초성+중성+종성)가 어떻게 저장되는지 보면서 다시한번 확인할 수 있다.

완전체 글자의 가장 처음인 `가`부터 알아보자. `가`를 UTF-8로 뽑으면 `ea b0 80`이 나온다. 또한 이 다음인 `ea b0 81`을 뽑아보면 `각`이 나온다. 이를 통해 완전체 글자는 받침이 있고 없고 상관없이 사전순으로 저장되어있음을 알 수 있다. 그리고 이 부분에서도 `0x80`에서 `0xbf`까지만 사용한다. 예를 들어 `ea b0 bf`가 `갿`인데 다음 글자인 `걀`은 `ea b1 80`이고, `꿿`이 `ea bf bf`인데 다음 글자인 `뀀`은 `eb 80 80`이다. 이렇게 `힣`인 `ed 9e a3`까지 순서대로 잘 저장되어 있다.

사전순으로 잘 저장되어 있는 것은 굉장히 긍정적인 부분이다. 그러나 `0x80`에서 `0xbf`까지만 사용한다는 것 때문에 코딩하기에 약간 귀찮음이 생긴다. 이에 비해 unicode는 잘(?) 저장되어있다. python에서 unicode를 뽑아보기 위해서는 `ord()` 함수를 쓰면 된다. 반대로 unicode에서 문자로 전환은 `chr()` 함수를 쓰면 된다. 예를 들어 `가`의 unicode를 알고싶다면

```
ord('가')
```

를 하면 된다. 이렇게 `가`를 뽑아보면 `0xac00`이 나온다. UTF-8처럼 중간에 `0x80`이나 `0xbf`같은 제한 없이 이 다음부터 `힣`인 `0xd7a3`까지 순서대로 저장된다. 기본 자음 또한 `ㄱ`인 `0x3131`부터 `ㅎ`인 `0x314e`까지 순서대로 저장되어있다. 그렇다면 unicode는 이렇게 순서대로 잘 저장되어있는데 UTF-8은 왜 이상하게 저장될까? 이는 unicode를 UTF-8로 변환하는 방법에 대해 알아보면 이에 대한 해답이 나온다. 먼저 힌트를 얻어보자면, `0x80`과 `0xbf`를 각각 이진수로 나타내보면 `10000000`과 `10111111`이다. 이를 다시 표현하면 `10 000000`과 `10 111111`이다.

Unicode가 UTF-8로 변환될 때, 모두 같은 방식으로 변환되지 않고 unicode 수의 범위에 따라 변환되는 방식이 다르다. 그 중 한글이 있는 `0x3131 ~ 0x314e`과 `0xac00 ~ 0xd7a3`은 `0x0800 ~ 0xffff`의 방식을 따르고, 이는 다음과 같다.

 - Unicode: ???????? ????????
 - UTF=8  : 1010???? 10?????? 10??????

더 쉽게 보이도록 색을 칠해보면 다음과 같다.

 - Unicode: ????<rr>????</rr> <rr>??</rr><bb>??????</bb>
 - UTF=8  : 1010???? 10<rr>??????</rr> 10<bb>??????</bb>

예를 들어 `가`의 Unicode는 `0xac00`이었다. 이를 이진수로 표현하면

`10100110 00000000`

이다. 따라서 이 Unicode가 매핑된 UTF-8은

`11101010 10011000 10000000`

이다. 이를 다시 16진수로 바꾸면 `ea b0 80`이다. 이 수는 아까 우리가 UTF-8로 뽑아봤던 `가`이다.

당연히 중간에 다른 처리할 필요가 없는 unicode가 더 다루기 쉬울 것이다. 이제 이 unicode에서 한글이 어떻게 저장되어있는지 더 자세히 알아보자.

먼저 초성을 기준으로 분석해보자. `가`의 unicode는 위에서 봤듯이 `0xac00`이다. 그 다음 받침이 없는 글자인 `까`의 unicode는 `0xae4c`이다. 그리고 그 다음인 `나`는 `0xb098`이고, `다`는 `0xb2e4`이다. 각 수의 차를 보면 588이다. 즉, **같은 초성을 가지는 글자는 588개씩 있음**을 알 수 있다. 확인을 위해 제일 처음인 `가`와 마지막인 `하`의 차이를 구해보면 10584이고 10584를 588로 나누면 정확히 18로 정확히 나눠 떨어지고, 이는 초성으로 올 수 있는 자음의 갯수 - 1 이다.

 > ㄱ ㄲ ㄴ ㄷ ㄸ ㄹ ㅁ ㅂ ㅃ ㅅ ㅆ ㅇ ㅈ ㅉ ㅊ ㅋ ㅌ ㅍ ㅎ

이제 한 초성 안에서 중성을 기준으로 분석해보자. `가` 다음인 `개`를 뽑아보면 `0xac1c`가 나오고, 그 다음인 `갸`를 뽑아보면 `0xac38`이 들린다. 이때 각 수의 차이를 보면 28이다. 따라서 위와 같이 이 또한 같은 초성과 중성을 가진 글자가 28개씩 있음을 유추할 수 있다. 이를 확인해보기 위해 588 을 28로 나눠보면 정확히 21로 나누어 떨어지고, 이는 중성에 올 수 있는 모음 갯수이다. 또한 28은 종성으로 올 수 있는 받침의 갯수 + 1이다. ( + 1 은 이유는 받침이 없는 경우)  

 > ㅏ ㅐ ㅑ ㅒ ㅓ ㅔ ㅕ ㅖ ㅗ ㅘ ㅙ ㅚ ㅛ ㅜ ㅝ ㅞ ㅟ ㅠ ㅡ ㅢ ㅣ

 > ㄱ ㄲ ㄳ ㄴ ㄵ ㄶ ㄷ ㄹ ㄺ ㄻ ㄼ ㄽ ㄾ ㄿ ㅀ ㅁ ㅂ ㅄ ㅅ ㅆ ㅇ ㅈ ㅊ ㅋ ㅌ ㅍ ㅎ

즉, 한글의 11172글자는 아래 그림과 같이 저장되었다고 볼 수 있다.

## 구현

먼저 `is_kr()`부터 구현해보자. C에서 어떤 문자가 알파벳인지 확인할 때 ASCII code를 이용해서 다음과 같이 확인한다.

```
if(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
    ...
}
```

한글도 위와 비슷한 방법으로 구현할 수 있다. 한글의 자음은 모두 `ㄱ`과 `ㅎ` 사이에 있고, 그 외의 글자는 모두 `가`와 `힣` 사이에 있다. 따라서 다음과 같이 판별할 수 있다.

```
def is_kr(c) :
    return (ord('ㄱ') <= ord(c) <= ord('ㅎ')) or (ord('가') <= ord(c) <= ord('힣'))
```

이제 `kr_list()`만 구현하면 된다. 이를 위해 우리가 위에서 분석했던 내용을 정리해보면 다음을 알아낼 수 있다.

 - 자음의 경우 `ord('ㄱ')`과 `ord('ㅎ')` 사이에 있다.
 - 그 외의 경우 `ord(c) - ord('가')`를 `kr_num`이라 하자.
 - `kr_num`이 28의 배수일 경우 받침이 없고, 이 글자부터 28글자는 모두 자음과 모음이 같다.
 - `kr_num`이 588의 배수일 경우 `초성 + ㅏ`이고, 이 글자부터 588글자는 모두 자음이 같다.

즉, **어떤 글자의 `kr_num` 이하의 가장 큰 28의 배수가 그 글자의 `초성 + 중성`이고, 가장 큰 588의 배수가 그 글자의 `초성 + ㅏ`이다.** `초성 + ㅏ`에서 초성만 추출하는 것은 자음 배열을 이용해서 구현할 수 있다. 따라서 `kr_list()`는 다음과 같이 구현할 수 있다.

```
def kr_list(s) :
    jaeum_list = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ' ]
    res = [s]
    kr_num = ord(s) - ord('가')
    if kr_num > 0 :
        res = res + jaeum_list[int(kr_num / 588)]
        if kr_num % 28 != 0 :
            res = res + chr((int(kr_num/ 28) * 28) + ord('가'))
    return res
```